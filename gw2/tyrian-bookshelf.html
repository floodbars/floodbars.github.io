<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Tyrian Bookshelf</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <!-- Don't use this in production: -->
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
    <style>
      li.complete {
        font-weight: bold;
      }
      li.locked {
        opacity: 0.3;
      }
      div.preview {
        white-space: pre-wrap;
      }
      #root {
        height: 100vh;
        overflow-y: hidden;
      }
    </style>
  </head>
  <body>
    <div id="root" class="container-fluid mh-100"></div>
    <script type="text/babel">
      function randomBoolean() {
          return (Math.floor(Math.random()*2) % 2) == 0;
      }
      class BookRepository {
      // TODO: metadata on how to unlock the achievements, authors, subtitles
        constructor(books, achievements) {
          this._books = books;
          this._achievements = achievements;
        }

        generateCompleteProgress() {
          return this._achievements.map(x => {
              return {
                bits: [],
                current: x.bits.length,
                done: true,
                id: x.achievementId,
                max: x.bits.length
              }
            });
        }

        // Generate random partial progress
        generatePartialProgress() {
          return this._achievements.map(achievement => {
              const maxBits = achievement.bits.length;
              var isDone = randomBoolean();
              var bits = [];
              var current = maxBits;
              if (!isDone) {
                for (var bit = 0; bit < maxBits; bit++) {
                  var isBitSet = randomBoolean();
                  if (isBitSet) {
                    bits.push(bit);
                  } else {
                    current--;
                  }
                }
                // Just in case it does turn out we did complete this achievement.
                if (current == maxBits) {
                  isDone = true;
                  bits = [];
                }
              }
              return {
                bits: bits,
                current: current,
                done: isDone,
                id: achievement.achievementId,
                max: maxBits
              }
            });
        }

        mapAchievementsToBooks(progression) {
          var achievements = {};
          this._achievements.forEach(x => achievements[x.achievementId] = x);

          var books = {};
          var output = [];
          this._books.forEach(x => {
            const book = {...x, status: "locked"};
            output.push(book);
            books[x.name] = book;
          });
          // TODO: book, paged, collation (multiple disparate things)

          progression.forEach(progress => {
            var achievement = achievements[progress.id];
            if (achievement == null) {
                return;
            }
            achievement["bits"]
              .map((bit, index) => {
                var isDone = progress.done || progress.bits.includes(index);
                if (isDone) {
                  var bookName = bit["book"];
                  if (bookName) {
                    if (bit["page"]) {
                        var book = books[bookName];
                        if (book == null) {
                            console.log("Unable to find book with name: " + bookName);
                        } else {
                            book.text.find(x => x.page == bit.page).isUnlocked = true;
                        }
                    } else {
                      books[bookName].status = "complete";
                    }
                  }
                }
              });
              if (progress.done && achievement.unlockOnCompletion) {
                achievement.unlockOnCompletion.forEach(bit => {
                  var bookName = bit["book"];
                  books[bookName].text.find(x => x.page == bit.page).isUnlocked = true;
                });
              }
          });

          output.forEach(book => {
            if (book.type == "paged") {
              const unlockedPages = book.text.filter(x => x.isUnlocked).length;
              const isComplete = unlockedPages > 0
              if (unlockedPages == 0) {
                // remain locked
              } else if (unlockedPages == book.text.length) {
                book.status = "complete";
              } else {
                book.status = "partial";
              }
            } else if (book.type == "book-paged") {
              if (book.status == "complete") {
                book.text.forEach(x => x.isUnlocked = true);
              }
            }
          });
          return output;
        }
      }

      class Book extends React.Component {
        constructor(props) {
          super(props);
          this.state = props.value;
          this.onClick = props.onClick;
        }

        render() {
          var context = "light";
          switch (this.state.status) {
            case "partial":
              context = "secondary";
              break;
            case "complete":
              context = "primary";
              break;
          }

          // TODO set active highlight somehow?
          return (
            <a href="#" className={"list-group-item-" + context + " list-group-item d-flex justify-content-between align-items-center"}
                onClick={this.onClick}>
              {this.state.name}
              {(this.state.status == "partial") &&
                <span className="badge badge-warning badge-pill">
                  {this.state.text.filter(x => !x.isUnlocked).length}
                </span>
              }
            </a>
          );
        }
      }
      
      class Preview extends React.Component {
        render() {
          var book = this.props.book;
          if (!book) {
            return ( 
              <div className="card">
                <div className="card-body text-secondary">
                  No book selected to preview.
                </div>
              </div>
            );
          }

          if (book.status == "locked") {
            return (
              <LockedBookPreview book={book} />
            );
          }

          if (book.type == "paged" || book.type == "book-paged") {
            return (
              <PagedBookPreview book={book} />
            );
          } else {
            return (
              <BookPreview value={book} />
            );
          }
        }
      }

      class BookPreview extends React.Component {
        render() {
          const book = this.props.value;
          return (
            <div className="card">
              <div className="preview card-body">
                <h4 className="card-title">{book.name}</h4>
                {book.text.split("\n").map((paragraph, index) => (
                  <p key={"p-" + index}>{paragraph}</p>
                ))}
              </div>
            </div>
          );
        }
      }

      class PagedBookPreview extends React.Component {
        render() {
          var book = this.props.book;
          if (!book) {
            return ("Uh-oh");
          }

          return (
            <div className="card">
              <div className="card-body">
                <h4 className="card-title">{book.name}</h4>
                {book.text.map(page => (
                  <Page page={page} key={page.page} />
                ))}
              </div>
            </div>
          );
        }
      }

      class LockedBookPreview extends React.Component {

        render() {
          var book = this.props.book;
          return (
            <div className="card border-warning">
              <div className="card-body text-warning">
                <h4 className="card-title">{book.name}</h4>
                You have yet to acquire this book.
              </div>
            </div>
          );
        }

      }

      class Page extends React.Component {
        render() {
          var text = "Page Missing";
          var style = "warning";
          if (this.props.page.isUnlocked) {
            text = this.props.page.text;
            style = "primary";
          }
          return (
            <div className={"card mb-3 border-" + style}>
              {this.props.page.description &&
                <div className="card-header">{this.props.page.description}</div>
              }
              <div className="preview card-body">
                {text.split("\n").map((paragraph, index) => (
                  <p key={"p-" + index}>{paragraph}</p>
                ))}
              </div>
            </div>
          );
        }
      }

      class CodexApp extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            apiKey: 'UNLOCK_ALL',
            areBooksLoaded: false,
            books: null,
            areAchievementsLoaded: false,
            achievements: null
          };
          this.handleChange = this.handleChange.bind(this);
          this.handleSubmit = this.handleSubmit.bind(this);
        }

        componentDidMount() {
          fetch("https://floodbars.github.io/gw2/data/bookshelf-achievements.json")
            .then(res => res.json())
            .then(
              (result) => {
                this.setState({
                  errors: this.state.errors,
                  achievements: result,
                  areAchievementsLoaded: true
                });
              },
              // Note: it's important to handle errors here
              // instead of a catch() block so that we don't swallow
              // exceptions from actual bugs in components.
              (error) => {
                this.setState({
                  areAchievementsLoaded: true,
                  books: this.state.books,
                  areBooksLoaded: this.state.areBooksLoaded,
                  error
                });
              }
            )
          fetch("https://floodbars.github.io/gw2/data/bookshelf-books.json")
            .then(res => res.json())
            .then(
              (result) => {
                this.setState({
                  errors: this.state.errors,
                  books: result,
                  areBooksLoaded: true
                });
              },
              // Note: it's important to handle errors here
              // instead of a catch() block so that we don't swallow
              // exceptions from actual bugs in components.
              (error) => {
                this.setState({
                  areBooksLoaded: true,
                  achievements: this.state.achievements,
                  areAchievementsLoaded: this.state.areAchievementsLoaded,
                  error
                });
              }
            )
        }

        render() {
          const { error, areBooksLoaded, areAchievementsLoaded, books, achievements, preview } = this.state;
          if (error) {
            return <div>Error: {error.message}</div>;
          } else if (!areBooksLoaded || !areAchievementsLoaded) {
            return <div>Loading data...</div>;
          } else {
            return (
              <div>
                <h1>Codex</h1>
                <form onSubmit={this.handleSubmit}>
                  <div className="form-group">
                  <label htmlFor="api-key">
                    API Key
                  </label>
                  <input
                    id="api-key"
                    className="form-control"
                    onChange={this.handleChange}
                    value={this.state.apiKey}
                  />
                  </div>
                  <button type="submit" className="btn btn-primary">
                    Load
                  </button>
                </form>
              </div>
            );
          }
        }

        handleChange(e) {
          this.setState({ apiKey: e.target.value });
        }

        handleSubmit(e) {
          e.preventDefault();
          if (!this.state.apiKey.length) {
            return;
          }
          this.setState(state => ({
            apiKey: state.apiKey
          }));
          const repository = new BookRepository(this.state.books, this.state.achievements);
          ReactDOM.render(
            <Shelf apiKey={this.state.apiKey} repository={repository} />,
            document.getElementById('root')
          );
        }
      }

      class Shelf extends React.Component {
        constructor(props) {
          super(props);
          this.apiKey = props.apiKey;
          this.repository = props.repository;

          this.state = {
            achievements: [],
            isLoaded: false,
            error: null,
            preview: null
          };
        }
        componentDidMount() {
          if (this.apiKey == 'UNLOCK_ALL') {
            const allUnlocked = this.repository.generateCompleteProgress();
            this.setState({
              achievements: allUnlocked,
              isLoaded: true
            });
            return;
          } else if (this.apiKey == 'UNLOCK_NONE') {
            this.setState({
              achievements: [],
              isLoaded: true
            });
            return;
          } else if (this.apiKey == 'UNLOCK_SOME') {
            const someUnlocked = this.repository.generatePartialProgress();
            this.setState({
              achievements: someUnlocked,
              isLoaded: true
            });
            return;
          }
          // TODO wrap this in an API-centric class/module
          var url = "https://api.guildwars2.com/v2/account/achievements?"
            + "access_token=" + this.apiKey;
          fetch(url)
            .then(res => res.json())
            .then(
              (result) => {
                this.setState({
                  achievements: result,
                  isLoaded: true
                });
              },
              // Note: it's important to handle errors here
              // instead of a catch() block so that we don't swallow
              // exceptions from actual bugs in components.
              (error) => {
                this.setState({
                  isLoaded: true,
                  error
                });
              }
            )
        }
        
        previewBook(book) {
          var newState = {
            achievements: this.state.achievements,
            isLoaded: this.state.isLoaded,
            error: this.state.error,
            preview: book
          };
          this.setState(newState);
        }

        render() {
          const { error, isLoaded, achievements, preview } = this.state;
          if (error) {
            return <div>Error: {error.message}</div>;
          } else if (!isLoaded) {
            return <div>Loading achievement progress...</div>;
          } else {
            var books = this.repository.mapAchievementsToBooks(achievements);
            books.sort((x, y) => x["name"].localeCompare(y["name"]));
            return (
              <div className="codex container-fluid h-100">
                <div className="row">
                  <h2>Tyrian Bookshelf</h2>
                </div>
                <div className="row" style={{height: "90%"}}>
                <div className="col-sm-4 h-100" style={{overflowY: "auto"}}>
                  <div className="list-group">
                    {books.map(book => (
                      <Book key={book.name} value={book} onClick={() => this.previewBook(book)} />
                    ))}
                  </div>
                </div>
                <div className="col-sm-8 h-100" style={{overflowY: "auto"}}>
                  <Preview book={preview} />
                </div>
              </div>
              </div>
            );
          }
        }
      }

      ReactDOM.render(
        <CodexApp />,
        document.getElementById('root')
      );

    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      Read this section for a production-ready setup with JSX:
      https://reactjs.org/docs/add-react-to-a-website.html#add-jsx-to-a-project

      In a larger project, you can use an integrated toolchain that includes JSX instead:
      https://reactjs.org/docs/create-a-new-react-app.html

      You can also use React without JSX, in which case you can remove Babel:
      https://reactjs.org/docs/react-without-jsx.html
    -->
  </body>
</html>